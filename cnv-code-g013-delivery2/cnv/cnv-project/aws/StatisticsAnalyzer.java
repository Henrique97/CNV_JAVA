package aws;
/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import BIT.highBIT.*;
import BIT.lowBIT.Local_Variable_Table;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Enumeration;
import java.nio.file.StandardOpenOption;
import java.net.*;

public class StatisticsAnalyzer {

    private static ThreadLocal<Metrics> metrics = new ThreadLocal<Metrics>(){
        @Override
        protected Metrics initialValue() {
            return new Metrics();
        }
    };

    public static void main(String[] argv) {
        try {
            File in_dir = new File(argv[0]);
            File out_dir = new File(argv[1]);

            if (in_dir.isDirectory() && out_dir.isDirectory()) {
                analyzeInstructions(in_dir, out_dir);
            }
            else {
                throw new NullPointerException("No Args");
            }
        }
        catch (NullPointerException e) {
            e.printStackTrace();
        }
    }



    public static void analyzeInstructions(File in_dir, File out_dir) {
        String filelist[] = in_dir.list();

        for (int i = 0; i < filelist.length; i++) {
            String filename = filelist[i];
            if (filename.endsWith(".class")) {
                String in_filename = in_dir.getAbsolutePath() + System.getProperty("file.separator") + filename;
                String out_filename = out_dir.getAbsolutePath() + System.getProperty("file.separator") + filename;
                ClassInfo ci = new ClassInfo(in_filename);


                for (Enumeration e = ci.getRoutines().elements(); e.hasMoreElements(); ) {
                    Routine routine = (Routine) e.nextElement();
                    InstructionArray instructions = routine.getInstructionArray();
                    for (Enumeration instrs = instructions.elements(); instrs.hasMoreElements(); ) {
                        Instruction instr = (Instruction) instrs.nextElement();
                        int opcode = instr.getOpcode();
                        if ((opcode==InstructionTable.invokespecial) ||
                                (opcode==InstructionTable.invokevirtual) ||
                                (opcode==InstructionTable.invokestatic)) {
                            instr.addBefore("aws/StatisticsAnalyzer", "registerCountOpCode", new Integer(opcode));
                        }
                        short instructionType = instr.getInstructionType();
                        if (instructionType == InstructionTable.LOAD_INSTRUCTION){
                            instr.addBefore("aws/StatisticsAnalyzer", "registerCountInstType", new Integer(instructionType));
                        }
                    }
                }
                ci.write(out_filename);
            }
        }
    }

    public static void printResults(String args) {
        Metrics threadMetrics = metrics.get();
        System.out.println("\t Invoke static: " + threadMetrics.invokestaticcount);
        String cnt = String.format("%d,%d,%d,%d",
                Thread.currentThread().getId(), threadMetrics.loadscount, threadMetrics.invokespecialcount,
                threadMetrics.invokevirtualcount);
        System.out.println(args);
        cnt= args + ","+ cnt;
        System.out.println("cnt: " + cnt);
        try {
            AmazonDynamoDBitems.writeDB(cnt);
        } catch (Exception e) {
            System.out.println("Error Writing To Database" + e);
        }
        threadMetrics.loadscount = threadMetrics.invokestaticcount = threadMetrics.invokespecialcount = threadMetrics.invokevirtualcount = threadMetrics.alerted=0;
    }

    public static void registerCountOpCode(int opcode)
    {
        Metrics threadMetrics = metrics.get();

        switch(opcode) {
            case InstructionTable.invokespecial:
                threadMetrics.invokespecialcount++;
                countDone();
                break;
            case InstructionTable.invokevirtual:
                threadMetrics.invokevirtualcount++;
                countDone();
                break;
        }
    }

    public static void registerCountInstType(int type)
    {
        Metrics threadMetrics = metrics.get();
        switch(type) {
            case InstructionTable.LOAD_INSTRUCTION:
                threadMetrics.loadscount++;
                countDone();
                break;
        }
    }

    public static void countDone() {
        Metrics threadMetrics = metrics.get();
        if(threadMetrics.estimatedCargo<=0) return;
        if(threadMetrics.loadscount * 0.05+ threadMetrics.invokespecialcount * 0.45 * Math.pow(10,threadMetrics.multiplierIs) +
                threadMetrics.invokevirtualcount * 0.5 * Math.pow(10,threadMetrics.multiplierIv)>=
                0.9* threadMetrics.estimatedCargo && threadMetrics.alerted==0) {
            send_alertToLB();
            threadMetrics.alerted=1;
        }
    }

    public static void setupJob(double estimatedCargo, int jobId, String address, long multiplierIs, long multiplierIv){
        metrics.get().estimatedCargo = estimatedCargo;
        metrics.get().jobId = jobId;
        metrics.get().address = address;
        metrics.get().multiplierIs = multiplierIs;
        metrics.get().multiplierIv= multiplierIv;
    }

    public static void send_alertToLB() {
        int jobId=metrics.get().jobId;
        String address = metrics.get().address;
        try{
            System.out.println(address);
            String rerouteUrl = address+ ":8000" + "/terminateJob?"+ "id=" + jobId;
            System.out.println("Alert from job" + jobId + " redirected to " + rerouteUrl);
            URL url = new URL(rerouteUrl);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("GET");
            con.setConnectTimeout(500000);
            con.setReadTimeout(500000);

            int status = con.getResponseCode();

            System.out.println("Job terminated");

        }catch (Exception timeout){ // SocketTimeoutException
            System.out.println("Error warning lb to terminate job" + timeout);
        }

    }
}
